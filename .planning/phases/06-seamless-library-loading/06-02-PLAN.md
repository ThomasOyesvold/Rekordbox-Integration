---
phase: 06-seamless-library-loading
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - electron/main.js
  - electron/preload.cjs
  - renderer/App.jsx
autonomous: true

must_haves:
  truths:
    - USBANLZ folder is auto-detected from standard Rekordbox install paths
    - Waveform mapping builds automatically during parse (no separate button)
    - Mapping is stored internally, never shown to users
    - Smart rebuild: mapping only rebuilds when ANLZ path changes or track count shifts >10%
    - "Build ANLZ Map" button and anlzMapPath input are removed from UI
  artifacts:
    - electron/main.js (detectPath handler + updated library:parse)
    - electron/preload.cjs (new bridge methods)
    - renderer/App.jsx (UI cleanup + auto-detect on mount)
  key_links:
    - buildAnlzMapping() in src/services/anlzMappingService.js used unchanged
    - attachAnlzWaveformSummaries() in src/services/anlzWaveformService.js used unchanged
    - Internal mapping path: app.getPath('userData') + '/anlz-mapping.json'
---

<objective>
Remove the manual "Build ANLZ Map" workflow. Waveforms build automatically when the user parses their library.

Purpose: Users currently need to know what USBANLZ is, find the folder, click a separate button, wait 10+ minutes, and understand what anlz-track-map.json is. None of this should be exposed to users.
Output: ANLZ path auto-detected on launch. Mapping built automatically inside `library:parse`. No user-visible JSON files.
</objective>

<execution_context>
@/home/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/home/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-seamless-library-loading/06-OVERVIEW.md

# Current ANLZ services (unchanged)
@src/services/anlzMappingService.js
@src/services/anlzWaveformService.js

# Files to modify
@electron/main.js
@electron/preload.cjs
@renderer/App.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add anlz:detectPath IPC handler</name>
  <files>electron/main.js</files>
  <action>
Add `const os = require('os');` near the top of main.js if not already present.

Add the handler:
```javascript
ipcMain.handle('anlz:detectPath', async () => {
  const candidates = [];

  // Windows native
  if (process.platform === 'win32' && process.env.APPDATA) {
    candidates.push(
      path.join(process.env.APPDATA, 'Pioneer', 'rekordbox', 'share', 'PIONEER', 'USBANLZ')
    );
  }

  // WSL: scan /mnt/c/Users/* — each Windows user profile
  if (process.env.WSL_DISTRO_NAME || process.env.WSL_INTEROP) {
    try {
      const users = fs.readdirSync('/mnt/c/Users');
      for (const user of users) {
        if (user.startsWith('.') || user === 'Public' || user === 'Default') continue;
        candidates.push(
          `/mnt/c/Users/${user}/AppData/Roaming/Pioneer/rekordbox/share/PIONEER/USBANLZ`
        );
      }
    } catch {}
  }

  // macOS
  if (process.platform === 'darwin') {
    candidates.push(
      path.join(os.homedir(), 'Library', 'Application Support', 'rekordbox', 'share', 'PIONEER', 'USBANLZ')
    );
  }

  for (const candidate of candidates) {
    try {
      if (fs.existsSync(candidate)) {
        return { path: candidate, detected: true };
      }
    } catch {}
  }
  return { path: null, detected: false };
});
```
  </action>
  <verify>
```bash
grep "anlz:detectPath" electron/main.js
grep "WSL_DISTRO_NAME" electron/main.js
```
  </verify>
  <done>
anlz:detectPath handler registered, checks Windows/WSL/macOS standard Rekordbox install locations
  </done>
</task>

<task type="auto">
  <name>Task 2: Update library:parse to auto-build ANLZ mapping</name>
  <files>electron/main.js</files>
  <action>
In the existing `library:parse` IPC handler, after the XML is parsed and `filteredTracks` is ready:

1. Accept `usbAnlzPath` from payload (in addition to existing `anlzMapPath`):
```javascript
const usbAnlzPath = typeof payload?.usbAnlzPath === 'string' ? payload.usbAnlzPath.trim() : '';
```

2. Define internal mapping path (hidden from users):
```javascript
const internalMappingPath = path.join(app.getPath('userData'), 'anlz-mapping.json');
```

3. Replace the existing `if (anlzMapPath)` block with:
```javascript
if (usbAnlzPath) {
  // Determine if mapping needs to be rebuilt
  let needsRebuild = true;
  try {
    const existing = JSON.parse(fs.readFileSync(internalMappingPath, 'utf8'));
    const savedPath = existing.usbAnlzPath || '';
    const savedCount = existing.stats?.totalTracks || 0;
    const currentCount = filteredTracks.length;
    const countDrift = Math.abs(currentCount - savedCount) / Math.max(currentCount, 1);
    needsRebuild = savedPath !== usbAnlzPath || countDrift > 0.1;
  } catch {
    // File missing or unparseable — rebuild
  }

  if (needsRebuild) {
    // Cancel any existing build
    if (anlzBuildController) anlzBuildController.abort();
    anlzBuildController = new AbortController();

    await buildAnlzMapping({
      tracks: filteredTracks,
      usbAnlzPath,
      outPath: internalMappingPath,
      signal: anlzBuildController.signal,
      onProgress: (p) => {
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('anlz:buildProgress', { ...p, stage: 'build' });
        }
      }
    });
  }

  try {
    anlzAttach = await attachAnlzWaveformSummaries(filteredTracks, {
      mappingPath: internalMappingPath,
      maxTracks: anlzMaxTracks
    });
  } catch (e) {
    anlzAttachError = e.message || String(e);
  }
} else if (anlzMapPath) {
  // Backward compat: explicit map path still works (existing behavior)
  try {
    anlzAttach = await attachAnlzWaveformSummaries(filteredTracks, {
      mappingPath: anlzMapPath,
      maxTracks: anlzMaxTracks
    });
  } catch (e) {
    anlzAttachError = e.message || String(e);
  }
}
```

**Important:** The `buildAnlzMapping` result contains `{ usbAnlzPath, stats, mapping }`. The `usbAnlzPath` field must be written into the output JSON so the next parse can read it back for change detection. Confirm that `anlzMappingService.js` writes `usbAnlzPath` into the output JSON; if not, add it to the mapping output object before writing.
  </action>
  <verify>
```bash
# New param accepted
grep "usbAnlzPath" electron/main.js | head -10

# Internal path used
grep "anlz-mapping.json" electron/main.js

# Rebuild logic present
grep "needsRebuild" electron/main.js

# Backward compat preserved
grep "anlzMapPath" electron/main.js | grep -v "usbAnlzPath"
```
  </verify>
  <done>
library:parse auto-builds ANLZ mapping when usbAnlzPath provided; smart rebuild detection; internal storage path
  </done>
</task>

<task type="auto">
  <name>Task 3: Expose new bridge methods in preload</name>
  <files>electron/preload.cjs</files>
  <action>
Add to the `rbfa` contextBridge object:

```javascript
detectAnlzPath: () => ipcRenderer.invoke('anlz:detectPath'),
onAnlzBuildProgress: (listener) => {
  const wrapped = (_event, value) => listener(value);
  ipcRenderer.on('anlz:buildProgress', wrapped);
  return () => ipcRenderer.removeListener('anlz:buildProgress', wrapped);
},
```

Update `parseLibrary` to pass `usbAnlzPath`:
```javascript
parseLibrary: (xmlPath, selectedFolders, options = {}) =>
  ipcRenderer.invoke('library:parse', {
    xmlPath,
    selectedFolders,
    anlzMapPath: options?.anlzMapPath || null,
    usbAnlzPath: options?.usbAnlzPath || null,
    anlzMaxTracks: options?.anlzMaxTracks
  }),
```
  </action>
  <verify>
```bash
grep "detectAnlzPath" electron/preload.cjs
grep "onAnlzBuildProgress" electron/preload.cjs
grep "usbAnlzPath" electron/preload.cjs
```
  </verify>
  <done>
detectAnlzPath, onAnlzBuildProgress bridge methods exposed; parseLibrary updated with usbAnlzPath param
  </done>
</task>

<task type="auto">
  <name>Task 4: Clean up App.jsx — remove manual ANLZ UI, add auto-detect</name>
  <files>renderer/App.jsx</files>
  <action>
**Remove these state variables:**
- `anlzMapPath` and `setAnlzMapPath`
- `anlzBuildSummary` and `setAnlzBuildSummary`
- `anlzBuildProgress` and `setAnlzBuildProgress`
- `isBuildingAnlzMap` and `setIsBuildingAnlzMap`

**Remove these functions:**
- `buildAnlzMap()`
- `cancelAnlzMapBuild()`

**Remove from UI:**
- "Optional ANLZ map path" text input and its wrapping `<div>`
- "Build ANLZ Map" button, its "Building..." state, and "Cancel" variant
- `anlzBuildProgress` progress display block

**Keep:**
- `usbAnlzPath` state (still needed for user to specify folder if auto-detect fails)
- `pickUsbAnlzFolder()` function (reused by SetupWizard in Plan 03)

**Add `anlzDetected` state:**
```javascript
const [anlzDetected, setAnlzDetected] = useState(false);
```

**Add auto-detect in the mount useEffect**, after loading saved state:
```javascript
// Auto-detect ANLZ path if not already saved
if (!savedState?.usbAnlzPath) {
  const detected = await bridgeApi.detectAnlzPath?.();
  if (detected?.path) {
    setUsbAnlzPath(detected.path);
    setAnlzDetected(true);
  }
} else {
  setAnlzDetected(false); // Path was manually set/saved
}
```

**Subscribe to anlz:buildProgress** during parse to show inline progress (add to parse function scope):
```javascript
const unsubAnlzProgress = bridgeApi.onAnlzBuildProgress?.((progress) => {
  // Update parse status message with waveform build progress
  // e.g., setParseStatusMessage(`Building waveform index: ${progress.scanned}/${progress.total} files...`)
});
// Unsubscribe in finally block
```

**Update `parse()` to pass usbAnlzPath:**
```javascript
const result = await bridgeApi.parseLibrary(xmlPath.trim(), selectedFolders, {
  usbAnlzPath: usbAnlzPath.trim(),
  anlzMaxTracks: 5000
});
```

**Update `saveState` calls** — remove `anlzMapPath` from all `bridgeApi.saveState({...})` calls.
  </action>
  <verify>
```bash
# Manual build UI removed
grep "Build ANLZ Map" renderer/App.jsx  # should return nothing
grep "buildAnlzMap" renderer/App.jsx     # should return nothing
grep "anlzMapPath" renderer/App.jsx      # should return nothing

# Auto-detect present
grep "detectAnlzPath" renderer/App.jsx
grep "anlzDetected" renderer/App.jsx

# usbAnlzPath still passed to parse
grep "usbAnlzPath" renderer/App.jsx | grep "parseLibrary"
```
  </verify>
  <done>
Manual "Build ANLZ Map" UI removed; auto-detect on mount; usbAnlzPath passed to parseLibrary; progress subscription added
  </done>
</task>

</tasks>

<success_criteria>
**Acceptance:**
1. No "Build ANLZ Map" button anywhere in the UI
2. No "ANLZ map path" text input anywhere in the UI
3. On app launch in WSL with standard Rekordbox install: `usbAnlzPath` is pre-filled automatically
4. Parsing library with ANLZ path set → waveform build runs automatically during parse
5. Second parse with same ANLZ path and same library → no rebuild (fast, uses cache)
6. Waveforms visible in track table after parse

**Testing:**
```bash
npm run start:electron:safe

# Auto-detect test:
# 1. Open DevTools → React state → confirm usbAnlzPath is pre-filled
# 2. No user action needed — path found from Rekordbox install

# Waveform integration test:
# 1. Parse library (ANLZ path set)
# 2. Should see progress messages: "Building waveform index..."
# 3. After parse: check anlzAttach summary → attached > 0
# 4. Track table should show colored waveform bars

# No rebuild test:
# 1. Parse library (mapping builds — slow first time)
# 2. Parse again immediately
# 3. No "Building waveform index" stage on second parse
# 4. Check: anlz-mapping.json exists in Electron userData dir (not in project root)

# UI cleanliness test:
grep "Build ANLZ Map" renderer/App.jsx  # empty
grep "anlzMapPath" renderer/App.jsx      # empty
```

**Edge cases:**
- ANLZ path not detected and user hasn't set one: parse works fine, no waveforms, no error
- ANLZ path set but mapping build fails/canceled: tracks still returned, anlzAttachError shown
- anlzMappingService writes usbAnlzPath into JSON output: verify and add if missing
</success_criteria>

<must_have_derivation>
**Goal:** Waveforms load automatically without any user-visible configuration steps

**Critical behaviors:**
- Auto-detect must check WSL paths (primary target platform)
- Mapping must save to internal userData path, not project directory
- Smart rebuild prevents 10-minute re-scan on every parse
- Backward compat: explicit anlzMapPath still works for power users

**Critical artifacts:**
- `anlz:detectPath` IPC handler (WSL/Windows/macOS paths)
- Updated `library:parse` with auto-build logic
- Cleaned-up App.jsx with no manual ANLZ build UI

**Critical connections:**
- `buildAnlzMapping()` from `anlzMappingService.js` is unchanged
- `attachAnlzWaveformSummaries()` from `anlzWaveformService.js` is unchanged
- `anlzBuildController` (AbortController) reused from existing main.js scope
- The mapping JSON output must include `usbAnlzPath` for change detection
</must_have_derivation>
