---
phase: 06-seamless-library-loading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - electron/main.js
  - electron/preload.cjs
  - renderer/App.jsx
autonomous: true

must_haves:
  truths:
    - App restores parsed library on launch without requiring re-parse
    - Library is stale-detected by comparing XML file modification time
    - User can trigger manual "Refresh Library" to re-parse when tracks change
    - Cached library loads in under 1 second
  artifacts:
    - electron/main.js (new IPC handlers)
    - electron/preload.cjs (new bridge methods)
    - renderer/App.jsx (cache load on mount)
  key_links:
    - Library state stored in SQLite `library_state` table
    - Stale detection uses file mtime comparison
    - Waveform data already cached in separate `anlz_waveform_cache` table
---

<objective>
Persist parsed library state in SQLite so the app restores instantly on every launch.

Purpose: Users currently must re-parse their 12K track library every time they open the app — even when nothing has changed. This is slow and frustrating.
Output: Library loads from SQLite cache on startup. User clicks "Refresh Library" only when they've added new tracks to Rekordbox.
</objective>

<execution_context>
@/home/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/home/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-seamless-library-loading/06-OVERVIEW.md

# Current state and parsing
@electron/main.js
@electron/preload.cjs
@renderer/App.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add library state SQLite table and IPC handlers</name>
  <files>electron/main.js</files>
  <action>
In `electron/main.js`, add two new IPC handlers using the existing SQLite db connection:

**Create table on db init:**
```javascript
db.exec(`
  CREATE TABLE IF NOT EXISTS library_state (
    id INTEGER PRIMARY KEY,
    xml_path TEXT NOT NULL,
    xml_mtime INTEGER NOT NULL,
    parsed_at TEXT NOT NULL,
    tracks_json TEXT NOT NULL,
    folders_json TEXT NOT NULL,
    summary_json TEXT NOT NULL,
    selected_folders_json TEXT NOT NULL DEFAULT '[]',
    track_count INTEGER NOT NULL DEFAULT 0
  )
`);
```

**Save handler:**
```javascript
ipcMain.handle('library:saveState', async (_event, payload) => {
  const { xmlPath, xmlMtime, parsedAt, tracks, folders, summary, selectedFolders } = payload;

  // Get actual mtime from filesystem if not provided
  let mtime = xmlMtime;
  if (!mtime) {
    try {
      const stat = fs.statSync(xmlPath);
      mtime = stat.mtimeMs;
    } catch {}
  }

  db.prepare(`
    INSERT OR REPLACE INTO library_state
      (id, xml_path, xml_mtime, parsed_at, tracks_json, folders_json, summary_json, selected_folders_json, track_count)
    VALUES
      (1, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    xmlPath,
    mtime,
    parsedAt || new Date().toISOString(),
    JSON.stringify(tracks),
    JSON.stringify(folders),
    JSON.stringify(summary),
    JSON.stringify(selectedFolders || []),
    tracks.length
  );

  return { saved: true };
});
```

**Load handler:**
```javascript
ipcMain.handle('library:loadState', async (_event, payload) => {
  const row = db.prepare('SELECT * FROM library_state WHERE id = 1').get();
  if (!row) return { found: false };

  // Check XML file still exists and mtime matches
  const xmlPath = row.xml_path;
  try {
    const stat = fs.statSync(xmlPath);
    const currentMtime = stat.mtimeMs;
    const stale = currentMtime !== row.xml_mtime;

    return {
      found: true,
      stale,
      xmlPath,
      parsedAt: row.parsed_at,
      trackCount: row.track_count,
      tracks: JSON.parse(row.tracks_json),
      folders: JSON.parse(row.folders_json),
      summary: JSON.parse(row.summary_json),
      selectedFolders: JSON.parse(row.selected_folders_json)
    };
  } catch {
    // XML file missing or unreadable — treat as stale
    return {
      found: true,
      stale: true,
      xmlPath,
      parsedAt: row.parsed_at,
      trackCount: row.track_count,
      tracks: [],
      folders: [],
      summary: null,
      selectedFolders: []
    };
  }
});
```

**Clear handler (for manual refresh):**
```javascript
ipcMain.handle('library:clearState', async () => {
  db.prepare('DELETE FROM library_state WHERE id = 1').run();
  return { cleared: true };
});
```
  </action>
  <verify>
```bash
# Handlers registered
grep -E "(library:saveState|library:loadState|library:clearState)" electron/main.js

# Table creation included
grep "library_state" electron/main.js
```
  </verify>
  <done>
SQLite library_state table created; saveState, loadState, clearState IPC handlers registered
  </done>
</task>

<task type="auto">
  <name>Task 2: Expose bridge methods in preload</name>
  <files>electron/preload.cjs</files>
  <action>
Add three methods to the `rbfa` contextBridge object in `electron/preload.cjs`:

```javascript
saveLibraryState: (payload) => ipcRenderer.invoke('library:saveState', payload),
loadLibraryState: () => ipcRenderer.invoke('library:loadState'),
clearLibraryState: () => ipcRenderer.invoke('library:clearState'),
```
  </action>
  <verify>
```bash
grep -E "(saveLibraryState|loadLibraryState|clearLibraryState)" electron/preload.cjs
```
  </verify>
  <done>
Bridge methods exposed for library state persistence
  </done>
</task>

<task type="auto">
  <name>Task 3: Load from cache on App mount; save after parse; add refresh</name>
  <files>renderer/App.jsx</files>
  <action>
**A. Load from cache on mount** (in the existing `useEffect` that calls `bridgeApi.loadState()`):

After loading app state (paths etc.), attempt to restore the library:
```javascript
const libraryCache = await bridgeApi.loadLibraryState?.();
if (libraryCache?.found && libraryCache.tracks?.length > 0) {
  setTracks(libraryCache.tracks);
  setFolders(libraryCache.folders || []);
  setSummary(libraryCache.summary || null);
  setSelectedFolders(libraryCache.selectedFolders || []);
  setXmlPath(libraryCache.xmlPath || '');
  setLibraryCacheInfo({
    parsedAt: libraryCache.parsedAt,
    stale: libraryCache.stale,
    trackCount: libraryCache.trackCount
  });
}
```

Add state variable: `const [libraryCacheInfo, setLibraryCacheInfo] = useState(null);`

**B. Save to cache after successful parse** (at the end of the `parse` function, after setting tracks):
```javascript
await bridgeApi.saveLibraryState?.({
  xmlPath: xmlPath.trim(),
  tracks: result.filteredTracks || [],
  folders: result.folders || [],
  summary: result.summary || null,
  selectedFolders
});
setLibraryCacheInfo({
  parsedAt: new Date().toISOString(),
  stale: false,
  trackCount: (result.filteredTracks || []).length
});
```

**C. Add "Refresh Library" handler** — clears SQLite cache then calls existing `parse()`:
```javascript
const refreshLibrary = async () => {
  await bridgeApi.clearLibraryState?.();
  setLibraryCacheInfo(null);
  await parse();
};
```

**D. Show cache status in UI** — near the Parse button, add:
```jsx
{libraryCacheInfo && (
  <div className="library-cache-status">
    {libraryCacheInfo.stale ? (
      <span className="cache-stale">Library may be outdated</span>
    ) : (
      <span className="cache-fresh">
        Loaded from cache · {formatRelativeDate(libraryCacheInfo.parsedAt)}
      </span>
    )}
    <button onClick={refreshLibrary} disabled={isParsing}>
      Refresh Library
    </button>
  </div>
)}
```
  </action>
  <verify>
```bash
# Cache load on mount
grep "loadLibraryState" renderer/App.jsx

# Save after parse
grep "saveLibraryState" renderer/App.jsx

# Refresh handler exists
grep "refreshLibrary" renderer/App.jsx

# UI status element
grep "library-cache-status" renderer/App.jsx
```
  </verify>
  <done>
Library cache loads on mount, saves after parse, Refresh Library button clears cache and re-parses
  </done>
</task>

</tasks>

<success_criteria>
**Acceptance:**
1. Parse library once; close and reopen app → library appears without re-parsing
2. Track table shows same tracks as before with all metadata
3. Summary stats (track count, etc.) restored correctly
4. If XML file modified since last parse: stale indicator visible
5. "Refresh Library" button appears; clicking it re-parses and updates cache
6. Library from cache loads in under 1 second for 12K tracks

**Testing:**
```bash
npm run start:electron:safe

# Test sequence:
# 1. Parse library with XML → tracks appear
# 2. Note track count and a specific track name
# 3. Close app completely
# 4. Reopen app → tracks should appear immediately without clicking Parse
# 5. Verify same track count and track name present
# 6. Summary stats should match previous parse
# 7. No "Build ANLZ Map" or parse step needed
# 8. "Refresh Library" button visible → click it → tracks reload

# Stale test:
# 1. Parse library
# 2. Touch the XML file (change its mtime):
#    touch /path/to/rekordbox.xml
# 3. Reopen app → stale indicator should appear
# 4. Waveforms should still load from anlz_waveform_cache SQLite table
```

**Edge cases:**
- XML file deleted: stale indicator, no crash
- First launch (no cache): normal parse flow, no error
- Cache has 0 tracks (corrupt): fall through to normal parse flow
</success_criteria>

<must_have_derivation>
**Goal:** Library restores from cache on startup — no re-parse required

**Critical behaviors:**
- Cache load must be transparent (user sees tracks immediately)
- Stale detection must be reliable (mtime comparison)
- Waveform data still served from existing anlz_waveform_cache SQLite (no double-caching)
- Refresh is always available if user adds new Rekordbox tracks

**Critical artifacts:**
- `library_state` SQLite table
- `library:saveState`, `library:loadState`, `library:clearState` IPC handlers
- Cache restore in App.jsx mount effect
- "Refresh Library" button and stale indicator in UI

**Critical connections:**
- Uses existing SQLite `db` connection in `electron/main.js`
- Works alongside existing waveform cache (`anlz_waveform_cache`)
- `selectedFolders` persisted so folder filter restores correctly
</must_have_derivation>
